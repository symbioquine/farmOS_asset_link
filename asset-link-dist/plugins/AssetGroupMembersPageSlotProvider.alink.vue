<script setup>
import { computed, inject, ref, onMounted, onUnmounted } from 'vue';

import { currentEpochSecond, parseJSONDate } from "assetlink-plugin-api";

import { useRouter } from 'vue-router'

const router = useRouter();

const props = defineProps({
  asset: {
    type: Object,
    required: true,
  },
});

const assetLink = inject('assetLink');

const loadingGroupMembers = ref(false);
const groupMembers = ref([]);

const groupMemberNodes = computed(() => {
  return groupMembers.value.map(member => {
    return {
      id: member.id,
      member,
      selectable: true,
    };
  });
});

const resolveCurrentGroupMembers = async () => {
  loadingGroupMembers.value = true;

  const logTypes = (await assetLink.getLogTypes()).map(t => t.attributes.drupal_internal__id);

  const populateGroupMembersFromLatestMembershipLogs = async (entitySource, entitySourceCache, queryOpts) => {

    const results = await entitySource.query(q => logTypes.map(logType => {
      return q.findRecords(`log--${logType}`)
        .filter({ attribute: 'is_group_assignment', op: 'equal', value: true })
        .filter({ attribute: 'status', op: 'equal', value: 'done' })
        .filter({ attribute: 'timestamp', op: '<=', value: currentEpochSecond() })
        .filter({
          relation: 'group.id',
          op: 'some',
          records: [{ type: props.asset.type, id: props.asset.id }]
        })
        .sort('-timestamp');
    }), {
      ...(queryOpts || {}),
      sources: {
        remote: {
          include: ['asset']
        }
      }
    });

    const logs = results.flatMap(l => l);

    const allPossibleMembers = logs.flatMap(log => log.relationships?.asset?.data);

    const membershipLogQueryPromises = [];

    // Query the possible members' logs in chunks of 50 to avoid calling the server with too
    // long of a query URL
    const maxMembersToQuery = 50;
    for (let i = 0; i < allPossibleMembers.length; i += maxMembersToQuery) {
      const chunkOfPossibleMembers = allPossibleMembers.slice(i, i + maxMembersToQuery);

      membershipLogQueryPromises.push(entitySource.query(q => logTypes.map(logType => {
        const logTypeName = `log--${logType}`;
        return q.findRecords(logTypeName)
          .filter({ attribute: 'is_group_assignment', op: 'equal', value: true })
          .filter({ attribute: 'status', op: 'equal', value: 'done' })
          .filter({ attribute: 'timestamp', op: '<=', value: currentEpochSecond() })
          .filter({
            relation: 'asset.id',
            op: 'some',
            records: chunkOfPossibleMembers
          })
          .sort('-timestamp');
        }),
        { ...(queryOpts || {}) }
      ));
    }

    const membershipLogResults = await Promise.all(membershipLogQueryPromises);

    const logsForAllPossibleMembersByLogId = membershipLogResults.flatMap(l => l).flatMap(l => l).reduce(function(byId, log) {
      byId[log.id] = log;
      return byId;
    }, {});

    const logsForAllPossibleMembers = Object.values(logsForAllPossibleMembersByLogId);

    const currentMembers = allPossibleMembers.flatMap(possibleMember => {
          const latestLog = logsForAllPossibleMembers
              .filter(log => log.relationships.asset.data.find(a => a.id === possibleMember.id))
              .reduce((logA, logB) => parseJSONDate(logA.attributes.timestamp) > parseJSONDate(logB.attributes.timestamp) ? logA : logB);

          if (!latestLog.relationships.group.data.find(g => g.id === props.asset.id)) {
            return [];
          }

          const currentMember = entitySourceCache.query((q) => q.findRecord({ type: possibleMember.type, id: possibleMember.id }));

          if (!currentMember || currentMember.attributes.status === 'archived') {
            return [];
          }

          return [{ latestLogDate: parseJSONDate(latestLog.attributes.timestamp), member: currentMember}];
      })
      .sort((a, b) => (a.latestLogDate - b.latestLogDate) || parseJSONDate(a.member.attributes.created) - parseJSONDate(b.member.attributes.created))
      .map(m => m.member);

    groupMembers.value = currentMembers;
  }

  await populateGroupMembersFromLatestMembershipLogs(assetLink.entitySource.cache, assetLink.entitySource.cache, {});

  await populateGroupMembersFromLatestMembershipLogs(assetLink.entitySource, assetLink.entitySource.cache, { forceRemote: true });

  loadingGroupMembers.value = false;
};

const onAssetLogsChanged = ({ assetType, assetId }) => {
  if (
    props.asset.type === assetType &&
    props.asset.id === assetId
  ) {
    resolveCurrentGroupMembers();
  }
};

let unsubber;
onMounted(() => {
  resolveCurrentGroupMembers();
  unsubber = assetLink.eventBus.$on("changed:assetLogs", onAssetLogsChanged);
});
onUnmounted(() => unsubber && unsubber.$off());

const onGroupMemberClicked = (id) => {
  if (!id) {
    return;
  }
  const clickedMember = groupMembers.value.find(l => l.id === id);

  router.push(`/asset/${clickedMember.attributes.drupal_internal__id}`);
};
</script>

<template>
  <div>
    <h5 class="q-my-xs">Group Members:</h5>
    <div
      class="col"
      style="
        height: auto;
        min-height: 160px;
        height: 25vh;
        position: relative;
        contain: strict;
        overflow: auto;
      "
    >
      <q-tree
        node-key="id"
        :nodes="groupMemberNodes"
        :selected="null"
        no-nodes-label="No group members found"
        @update:selected="(id) => onGroupMemberClicked(id)"
        class="q-ml-md"
      >
        <template v-slot:default-header="prop">
          <entity-name :entity="prop.node.member"></entity-name>
        </template>
      </q-tree>
    </div>
  </div>
</template>

<script>
export default {
  onLoad(handle) {
    handle.defineSlot('net.symbioquine.farmos_asset_link.slots.v0.group_members', slot => {
      slot.type('page-slot');

      slot.showIf(context => context.pageName === 'asset-page' && context.asset.type === 'asset--group');

      slot.component(handle.thisPlugin);
    });
  }
}
</script>
